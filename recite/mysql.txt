
三范式
1.原子性,同一列的数据不可再分割，【比如 student 字段 不能 填 （'Tom,18岁'），18岁要再起个字段】
2.唯一性约束，非主键必须依赖与主键
3.冗余性约束，非主键的字段不能相互依赖

设计原则
1.避免冗余，容易导致数据不一致
2.一个表只做自己的事情，无关的数据不要在存储在同一表
3.一个字段不要出现分隔符，或一个字段存多个数据信息


事务
指的是一个序列操作，其中的sql语句要么全部成功，要么失败
特性（ACID）
1.原子性:要么全部成功，要么全部失败
2.一致性:执行事务的开始和结束都不会对数据的造成破坏
3.隔离性:多个事务对数据进行读写修改操作,隔离性保证多个事务之间不会相互影响
4.持久性:事务执行成功完成后，对数据的修改是永久的


脏读，幻读，不可重复读
脏读：一个事务正在修改数据且未提交到数据库，另外一个事务读取了当前数据库的数据
幻读：一个事务读取数据，另一个事务正在删除或新增数据改变第一个事务的结果集
不可重复读：一个事务多次读取数据，另一个事务正在修改数据，第一个事务开始读的和后来读到的数据不一致

锁
共享锁（s锁）:读锁,可以通过lock in share mode 实现，这个时候只能读不能写,在符合条件的行, 例如：select * from test where id = 1 lock in share mode;
排它锁（x锁）:写锁，会阻塞其他读写和写锁，又分为表锁和行锁
表锁:开销最小，对表进行写操作，需要获得写锁，会阻塞该表的所有读写操作
行锁:最大锁开销，可以最大程度地支持并发处理
乐观锁:版本号判断
悲观锁:for update  实现
死锁:多个事务在同一资源上互相占用，互相锁定其他事务，造成恶性循环
解决：使用低隔离级别
*********************************
查询 正在执行的事务：
SELECT * FROM information_schema.INNODB_TRX
查看正在锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
查看等待锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;

KILL id 杀掉
*********************************

隔离级别
查看当前隔离级别：select @@tx_isolation
读未提交:READ_UNCOMMITTED,
读已提交:READ_COMMITED,
可重复读:REPEATABLE_READ
串行化:SERLALIZABLE,最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样


主从复制
